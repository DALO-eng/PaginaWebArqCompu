<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles/styles.css">
    <link href="https://fonts.googleapis.com/css2?family=RocknRoll+One&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/be539b68f8.js" crossorigin="anonymous"></script>
    <title>Team Luciernagas</title>
</head>
<body>
    <header id="main_header">
        <div class="header_figure">
            <figure>
                <img src="https://i.ibb.co/ngZ072R/logo-horizontal.png" alt="Logo luciernagas">
            </figure>
        </div>
        <div id="navegator">
            <nav>
            <ul>
                <li><a href="#Inicio">Inicio</a></li>
                <li><a href="#Integrantes">Integrantes</a></li>
                <li><a href="#Practicas">Prácticas</a></li>
                <li><a href="#Proyecto">Proyecto</a></li>
            </ul>
            </nav>
        </div>
    </header>
    <main>
        <section id="Inicio">
            <div id="hero_text">
                <div id="hero_title">
                    <h1>!Bienvenido a <strong>Team Luciernaga!</strong></h1>
                </div>
                <div id="hero_content">
                    <p>Bienvenido al sitio web del Team Luciernaga para la clase de Arquitectua de Computadores Grupo A1 2021-2, en este sitio se publicarán las prácticas y el proyecto final de la asignatura.</p>
                </div>
            </div>
            <div id="hero_image">
                <figure>
                    <img src="https://i.ibb.co/z7hWH1F/logo-vertical.png" alt="Logo grande">
                </figure>
            </div>
        </section>
        <section id="Integrantes">
            <div class="title_section">
                <h2>Integrantes</h2>
            </div>
            <div id="members">
                <ul>
                    <li>
                        <img src="https://i.ibb.co/2Wz9sVM/daniel.jpg" alt="Foto_Daniel" width="500" height="500" class="member_image">
                        <div class="member">
                            <div class="member_name">
                                <h3>Daniel Alejandro León Ortiz</h3>
                            </div>
                            <div class="member_info">
                                <p>Estudiante de Ingeniería de Sistemas de 19 años de edad con pasión en el Deep Learning y el desarrollo Web, esmerado en el aprendizaje diario para mejorar sus competencias cada día más, durante su proceso de formación ha desarrollado diferentes valores tales como el entusiasmo, optimismo y dedicación en cada proyecto que se le enfrente. Durante su proceso de formación ha manejado varias tecnologías como: C++, Python, HTML5, CSS, Javascript, Angular, React, SQL, MongoDb, TygerGraph, NodeJs, Express, entre otros. Sus planes a futuro consiste en masterizar sus actuales capacidades y enfocarse en nuevas áreas como el desarrollo de videojuegos.</p>
                                <q>Tu échale ganas que no sabes cuanto tiempo te queda rey</q>
                                <div class="informacion">
                                    <div class="enlaces">
                                        <h4>Enlaces</h4>
                                        <ul>
                                            <li><a href="https://github.com/DALO-eng" target="_blank"><i class="fab fa-github"></i></a></li>
                                            <li><a href="https://www.linkedin.com/in/daniel-alejandro-leon-ortiz-17b038225/" target="_blank"><i class="fab fa-linkedin"></i></a></li>
                                        </ul>
                                    </div>
                                    <div class="contacto">
                                        <h4>Contacto</h4>
                                            <ul>
                                                <li>daniel2190064@correo.uis.edu.co</li>
                                            </ul> 
                                    </div>                                  
                                </div>
                            </div>
                        </div>
                    </li>
                    <hr>
                    <li>
                        <img src="https://i.ibb.co/zRjt8rQ/Yerson.jpg" alt="Foto_Yerson" width="500" height="500" class="member_image">
                        <div class="member">
                            <div class="member_name">
                                <h3>Yerson Stewell Ibarra Rueda</h3>
                            </div>
                            <div class="member_info">
                                <p>Yerson Stewell Ibarra Rueda (Cúcuta, norte de Santander; 9 de enero de 2001), es un estudiante de sexto semestre de ingeniería de sistemas actualmente es integrante del grupo luciérnaga, su carrera da inicio en el año 2019 en la universidad industrial de Santander, en el transcurso de la carrera ha realizado diversos proyectos para las materias de sistemas digitales, bases de datos, programación, etc. Actualmente reside en Cúcuta, pero por motivos de estudio suele estar en Bucaramanga.
                                    Es un gran aficionado a la programación y todas las ramas que están implican como el desarrollo de nuevas tecnologías y software, para futuro tiene varios proyectos como desarrollador de videojuegos y planea también seguir con su estudio con el fin de realizar una maestría.</p>
                                <q>Si puedes imaginarlo puedes programarlo</q>
                                <div class="informacion">
                                    <div class="enlaces">
                                        <h4>Enlaces</h4>
                                        <ul>
                                            <li><a href="https://www.facebook.com/yersonstewer.ibarrarueda" target="_blank"><i class="fab fa-facebook-square"></i></a></li>
                                        </ul>
                                    </div>
                                    <div class="contacto">
                                        <h4>Contacto</h4>
                                            <ul>
                                                <li>yersonibarra14@gmail.com</li>
                                            </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </li>
                    <hr>
                    <li>
                        <img src="https://i.ibb.co/F8Rt8HT/catalina.jpg" alt="Foto_Catalina" width="500" height="500" class="member_image">
                        <div class="member">
                            <div class="member_name">
                                <h3>Yaire Catalina Lopez Santana</h3>
                            </div>
                            <div class="member_info">
                                <p>Yaire Catalina López Santana, nació el 13 de agosto del 2001 en San Gil - Santander, desde niña se ha destacado por su capacidad de liderazgo y por su responsabilidad, siempre participando en actividades extracurriculares como danzas y deportes. Desde el 2010 practica voleibol, ha tenido varios logros en este deporte. En el 2018 ingresó a la Universidad Industrial de Santander a la carrera Ingeniería de Sistemas. Desde que ingresó se ha apasionado por lo que hace, perteneció al semillero de investigación MACV  desarrollado por el grupo de investigación BIVL²ab en el 2020. Ha trabajado en lenguajes como C++, Java, HTML5, CSS, SQL y su favorito que es Python. Entre sus deseos está profundizar sus conocimientos en Frontend y Backend para llegar a ser una ingeniera Full Stack y después de esto seguir creciendo en ámbito laboral.</p>
                                <q>No te detengas hasta que te sientas orgullosa</q>
                                <div class="informacion">
                                    <div class="enlaces">
                                        <h4>Enlaces</h4>
                                        <ul>
                                            <li><a href="https://www.instagram.com/yairelopez/?hl=es" target="_blank"><i class="fab fa-instagram"></i></a></li>
                                        </ul>
                                    </div>
                                    <div class="contacto">
                                        <h4>Contacto</h4>
                                        <ul>
                                            <li>yairecata.13lopez@gmail.com</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </li>
                    <hr>
                    <li>
                        <img src="https://i.ibb.co/6Bkx0qd/brayan.jpg" alt="Foto_Brayan" width="500" height="500" class="member_image">
                        <div class="member">
                            <div class="member_name">
                                <h3>Brayan Andres Quintero Pinto</h3>
                            </div>
                            <div class="member_info">
                                <p>Brayan Andrés Quintero Pinto es un estudiante de sexto nivel de Ingeniería de Sistemas de la Universidad Industrial de Santander, amante de la ciencia, la computación, y en general de la tecnología. 
                                    Oriundo del municipio de Girón que reside en Floridablanca. Pseudoescritor. Interesado y curioso por las ciencias de la computación, especialmente en la minería de datos, aprendizaje automático e inteligencia artificial. Aspira poder seguir en la academia y aportarle a la investigación en Colombia.
                                </p>
                                <q>La mejor forma de predecir tu futuro es crearlo</q>
                                <div class="informacion">
                                    <div class="enlaces">
                                        <h4>Enlaces</h4>
                                        <ul>
                                            <li><a href="https://www.linkedin.com/in/brayanquinteroa/" target="_blank"><i class="fab fa-linkedin"></i></a></li>
                                            <li><a href="https://www.instagram.com/brayanquinteroa/" target="_blank"><i class="fab fa-instagram"></i></a></li>
                                        </ul>
                                    </div>
                                    <div class="contacto">    
                                        <h4>Contacto</h4>
                                            <ul>
                                                <li>brayan2190083@correo.uis.edu.co</li>
                                            </ul>
                                    </div>
                                </div>
                            </div>
                        </div>  
                    </li>
                    <hr>
                    <li>
                        <img src="https://i.ibb.co/nzrVspH/camilo.png" alt="Foto_Camilo" width="500" height="500" class="member_image">
                        <div class="member">
                            <div class="member_name">
                                <h3>Camilo Jose Pereira Millan</h3>
                            </div>
                            <div class="member_info">
                                <p>Camilo José Pereira Millán, estudiante de Ingeniería en Sistemas en la Universidad Industrial de Santander (UIS), actualmente cursando séptimo semestre de la carrera, apasionado por las nuevas tecnologías y la programación; autodidacta y apasionado por saber y conocer todo sobre el área de la tecnología e informática con conocimientos básicos en programación web, bases de datos, python y java, además entusiasta de la astronomía y la ciencia, aspirante a poder enseñar a las demás personas todo lo que se trate del mundo de la informática y computación. </p>
                                <q>De los errores se aprende, del exito... no mucho</q>
                                <div class="informacion">
                                    <div class="enlaces">
                                        <h4>Enlaces</h4>
                                        <ul>
                                            <li><a href="https://www.linkedin.com/in/camijopemi/" target="_blank"><i class="fab fa-linkedin"></i></a></li>
                                        </ul>
                                    </div>
                                    <div class="contacto">      
                                        <h4>Contacto</h4>
                                        <ul>
                                            <li>camilo2171845@correo.uis.edu.co</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </li>
                    <hr>
                </ul>
            </div>
        </section>
        <section id="Practicas">
            <div class="title_section">
                <h2>Prácticas</h2>
            </div>
                <details>
                    <summary>Práctica 1: Familiarizándose con las sesiones prácticas e introducción al curso</summary>
                    <article class="practica">
                        <div class="titulo_practica">
                            <h2>Práctica 1: Familiarizándose con las sesiones prácticas e introducción al curso</h2>
                        </div>  
                        <div class="descripcion_practica">
                            <p>Observe la charla de TED dada por George Dyson, The Birth of Computers y las diapositivas
                                contenidas en este sitio sobre la evolución histórica responda las siguientes preguntas,
                                de manera concreta, si es necesario complementando con otras fuentes de información que
                                    busque al momento de hacer el informe (Recuerde que en la plataforma de TED puede colocar
                                    subtítulos en español):</p>
                        </div>
                        <div class="desarrollo_practica">
                            <div class="informe">
                                <div class="video_informe">
                                    <iframe width="560" height="315" src="https://www.youtube.com/embed/w3WojgsdQIw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                                    <p>El caso de no cargar el video, puede darle click <a href="https://youtu.be/w3WojgsdQIw" target="_blank"> Aqui</a></p>
                                </div>
                                <ol type="1"> 
                                    <li>
                                        <h4>¿Qué es lo más trascendental para cada uno de ustedes en esta charla?</h4>
                                        <p><span>Daniel:</span> En lo personal la parte más trascendental de la charla se basa en donde se listan los materiales como los 40 tubos o ese microprocesador muy sensible a perturbaciones electromagnéticas. Ya que al ver estos materiales en el resultado final, se puede observar la gran evolución que han tenido las computadoras a lo largo de los años, siendo cada vez más compactas y capaces de realizar tareas mucho más complejas.</p>
                                        <p><span>Yerson:</span> Ver cómo la idea de una máquina estaba ya planteada mucho antes de lo que pensamos como Thomas Hobbes en 1651 ya había explicado como la aritmética y la lógica eran lo mismo, y que si quieres pensamiento artificial y lógica artificial, todo esto era posible utilizando la aritmética, otro aspecto a destacar es que incluso en estos tiempos sin contar con el equipo adecuado ya se tenía la idea de hacer que una máquina hiciera cálculos matemáticos complejos que tardariamos mucho tiempo si lo hicieramos manualmente.</p>
                                        <p><span>Brayan:</span> Es importante destacar el trasfondo matemático, físico y electrónico que hubo detrás de la invención de la computación, al igual que el trabajo técnico y la mano de obra que permitieron la arquitectura que hasta nuestros días es utilizada como molde para el desarrollo de las máquinas de cómputo y diversos tipos de computadora.</p>
                                        <p><span>Catalina:</span> A mi parecer es escuchar acerca del inicio de la computación, ver las notas de esas primeras personas que pensaron en esto. Saber que desde 1651 ya se pensaba en hacer máquinas de cómputo y lograron encontrar la forma de multiplicar y dividir únicamente con adición. Estos primeros pasos me parecen trascendentales.</p>
                                        <p><span>Camilo:</span> Los más trascendental de la charla fue la historia de los inicios de la computación en cómo desde ya años atrás se tenía ya previsto ello con teorías e investigaciones como la de Thoma Hobbs y Leibniz con respecto a que afirmaban que la aritmética y la lógica eran lo mismo, con la lógica artificial se podría crear con solo implementando la aritmética (suma) además de ello también en como en la creación de la máquina se presentaron muchas fallas tanto como en el software y el hardware, lo más interesante fue en la bitácora que iba desarrollando cada uno de los integrantes de éste proyecto.</p>
                                    </li>
                                    <li>
                                        <h4> ¿Qué situaciones "cotidianas" encuentra hoy en día en las máquinas de cómputo que prevalecen desde los primeros días de esas primeras máquinas de computación?</h4>
                                        <p>Dos de las principales situación que aún hoy en día realizan las computadoras son el guardado y lectura de memoria; y el conteo, el cual permite realizar un gran número de tareas, desde tener un contador de cierto elemento, hasta realizar operaciones matemáticas complejas.</p>
                                        <p>Otra situaciones cotidiana que aún se presentan en las máquinas de hoy en día en el tema de las instrucciones para ellas (programación) ya que como se menciona en la charla estas primeras máquinas sus instrucciones deberían darse  en detalles absolutamente exhaustivos algo que hoy en la actualidad se sigue presentando con respecto a la programación de las máquinas.</p>
                                    </li>
                                    <li>
                                        <h4>Compare las principales características de su teléfono celular o del PC que tiene junto a usted al momento de hacer este informe (capacidad de memoria,  almacenamiento, consumo energético, capacidad de procesamiento e incluso complejidad), con las de esas máquinas pioneras. ¿Cuales han sido los cambios más dramáticos?</h4>
                                        <p>Se tomarán en comparación la computadora de primera generación UNIVAC 1 con el MSI GE75 Raider:</p>
                                        <table>
                                            <tr>
                                                <td></td>
                                                <td>UNIVAC</td>
                                                <td>MSI</td>
                                            </tr>
                                            <tr>
                                                <td>Memoria</td>
                                                <td>32 Kb</td>
                                                <td>1 Tb</td>
                                            </tr>
                                            <tr>
                                                <td>Consumo de energía</td>
                                                <td>125 kW</td>
                                                <td>203 W</td>
                                            </tr>
                                            <tr>
                                                <td>Capacidad de procesamiento</td>
                                                <td>2.25 MHz</td>
                                                <td>2.60 GHz</td>
                                            </tr>
                                        </table>
                                        <p>Durante estos 70 años desde el primer lanzamiento comercial de ésta máquinas hasta la fecha de hoy (2021) ha avanzado mucho el tema de la optimización y mejoramiento de estas, cabe resaltar que todo esto conlleva a un gran trabajo por distintos profesionales como físicos, eléctricos, matemáticos, químicos y entre otros, además es de suma importancia que gracias a la creación del transistor estas máquinas pudieron tener un gran salto a su evolución y mejorar tanto en tamaño como en tiempo de procesamiento y almacenamiento.</p>
                                    </li>
                                    <li>
                                        <h4>Hoy en día se habla mucho de la cuarta revolución industrial y la transformación digital. ¿Qué es cada una de ellas? Suponiendo que se gradúa mañana ¿Tiene claro (o no) cómo hacer parte de esas transformaciones? Justifique su respuesta.</h4>
                                        <p>La cuarta revolución industrial y la transformación digital son dos conceptos bastante relacionados. El primero hace referencia al avance tecnológico, caracterizado por la transformación digital, en el que todos los aspectos de la sociedad humana se verán afectados por las nuevas tecnologías, como lo son: la robótica, la inteligencia artificial, el internet de las cosas, la computación cuántica, entre otros.</p>
                                        <p>Con el conocimiento que tengo hasta ahora, si me graduara mañana, no me sentiría plenamente capacitado para hacer parte de esta transformación, pues aún hay demasiados vacíos en lo que a mi formación académica y profesional respecta. Necesitaría algo más de tiempo y experiencia en el ámbito laboral para así poder hacer parte de esta transformación digital.</p>
                                    </li>
                                    <li>
                                        <h4>En este momento hay una discusión entre expertos que afirman que actualmente la pandemia aceleró esa transformación digital y otros que dicen que ha sido todo lo contrario. Como grupo, ¿Cuál es su punto de vista?</h4>
                                        <p>La pandemia generó bastantes daños a nivel mundial, ya que no se podían realizar un gran número de actividades como se realizaban normalmente, generando graves consecuencias como crisis económicas, gran número de despidos, cancelación de proyectos, etc. Sin embargo, a medida que pasaba el tiempo, la sociedad empezó a utilizar diferentes herramientas para reemplazar las actividades que no se podían
                                            realizar ahora, estos usos en nuevas tecnologías hizo ver a la gente que estas facilitan mucho las tareas que antes costaban mucho más tiempo o capital, incrementando la integración de nuevas  tecnologías en diferentes áreas de una empresa, y por ende, acelerando la transformación digital.
                                        </p>
                                    </li>
                                </ol>
                            </div>
                        </div>
                    </article>
                </details>
                <details>
                    <summary>Práctica 2: Conociendo Nand2Tetris</summary>
                    <article class="practica">
                        <div class="titulo_practica">
                            <h2>Práctica 2: Conociendo Nand2Tetris</h2>
                        </div>
                        <div class="descripcion_practica">
                            <p>Los profesores Noam Nisan y Simon Schocken, autores del libro The Elements of Computing Systems,
                            Building a Modern Computer from First Principles, disponible <a href="http://wiki.sc3.uis.edu.co/index.php/File:TheElementsOfComputingSystems.pdf" target="_blank">aquí</a>, crearon Nand2Tetris un conjunto
                            de herramientas software para entender ciertos elementos de arquitectura de computadores que
                            precisamente son tratados en el libro y en el curso que ellos dirigen en sus universidades
                            y que nosotros tomamos como uno de las referencias de base. Instalando y reconociendo las
                            principales características de Nand2Tetris, responda lo siguiente, realizando el proyecto 1:
                            Lógica Booleana: <a href="https://www.nand2tetris.org/project01" target="_blank">https://www.nand2tetris.org/project01</a></p>
                        </div>
                        <div class="desarrollo_practica">
                            <div class="informe">
                                <div class="video_informe">
                                    <iframe width="560" height="315" src="https://www.youtube.com/embed/Y0pQ0cBoXik" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                                    <p>El caso de no cargar el video, puede darle click <a href="https://www.youtube.com/watch?v=Y0pQ0cBoXik" target="_blank"> Aqui</a></p>
                                </div>
                                <ol>
                                    <li>
                                        <h4>¿Cuál es el objetivo de ese proyecto con sus palabras y describa que debe hacer para desarrollarlo?</h4>
                                        <p>El objetivo de esta práctica consiste en comprender las compuertas lógicas básicas utilizadas en un computador mediante
                                            el uso de otras compuertas, utilizando incialmente la compuerta NAND. Para alcanzar este objetivo, se usará el software nand2tetris, el cual mediante archivos HDL
                                                y a partir de la compuerta NAND, se simularán y comprobarán las siguientes compuertas:  Not, And, Or, Xor, Mux, DMux, Not16, And16, Or16, Mux16, Or8Way, Mux4Way16, Mux8Way16, DMux4Way y DMux8Way.
                                            </p>
                                    </li>
                                    <li>
                                        <h4>Construir las compuertas solicitadas y documentar los resultados:</h4>
                                        <ul>
                                            <li>
                                                <h3>Compuerta NOT</h3>
                                                <div class="info_compuerta">
                                                    <img src="https://i.ibb.co/J3syt8t/not.png" alt="Not">
                                                    <div class="codigo_compuerta">
                                                        <h4>Código:</h4>
    <pre>
    <code>
    CHIP Not {
        IN in;
        OUT out;

        PARTS:
        Nand(a = in, b = in, out = out);
    }
    </code>
    </pre>
                                                    </div>
                                                </div>
                                                <p>Esta compuerta es una negación, si la entrada está en nivel alto la salida va a estar en nivel bajo y viceversa. Otra forma de expresarse
                                                    consiste en el ingreso del mismo valor en ambas entradas de una compuerta NAND.
                                                </p>
                                            </li>
                                            <li>
                                                <h3>Compuerta AND</h3>
                                                <div class="info_compuerta">
                                                    <img src="https://i.ibb.co/PcX1SFt/AND.png" alt="And">
                                                    <div class="codigo_compuerta">
                                                        <h4>Código:</h4>
    <pre>
    <code>
    CHIP And {
        IN a, b;
        OUT out;

        PARTS:
        Nand(a=a, b=b, out = nand);
        Not(in = nand, out = out);
    }
    </code>
    </pre>
                                                    </div>
                                                </div>
                                                <p>Esta compuerta es una conjunción, la salida estará en nivel alto únicamente si ambas entradas están en nivel alto.
                                                    Otra forma de representarlo es utilizar una compuerta NAND y posteriormente usar una compuerta NOT con la salida obtenida.
                                                </p>
                                            </li>
                                            <li>
                                                <h3>Compuerta OR</h3>
                                                <div class="info_compuerta">
                                                    <img src="https://i.ibb.co/Fx3D5C9/or.png" alt="Or">
                                                    <div class="codigo_compuerta">
                                                        <h4>Código:</h4>
    <pre>
    <code>
    CHIP Or {
    IN a, b;
        OUT out;

        PARTS:
        Not(in = a, out = not1);
        Not(in = b, out = not2);
        Nand(a = not1, b = not2, out = out);
    }   
    </code>
    </pre>
                                                    </div>
                                                </div>
                                                <p>Esta compuerta es una disyunción, la salida estará en nivel alto si al menos una de sus entradas están en nivel alto.
                                                    Otra forma de representarlo es utilizar una compuerta NOT para cada entrada y posteriormente obtener esas salidas y usar
                                                    una compuerta NAND con ellas.
                                                </p>
                                            </li>
                                            <li>
                                                <h3>Compuerta XOR</h3>
                                                <div class="info_compuerta">
                                                    <img src="https://i.ibb.co/dBCMMtK/xor.png" alt="Xor">
                                                    <div class="codigo_compuerta">
                                                        <h4>Código:</h4>
    <pre>
    <code>
    CHIP Xor {
        IN a, b;
        OUT out;

        PARTS:
        Not(in = a, out = outA);
        Not(in = b, out = outB);
        And(a = a, b = outB, out = and1);
        And(a = outA, b = b, out = and2);
        Or(a = and1, b = and2, out = out);
    }   
    </code>
    </pre>
                                                    </div>
                                                </div>
                                                <p>En esta compuerta la salida estará en un nivel alto si sus dos entradas tienen niveles opuestos (alto y bajo).
                                                    Otra forma de representarlo es utilizar 2 compuertas AND, en donde una de sus entradas es negada, una vez obtenida ambas salidas,
                                                    estas se conectan a una compuerta OR. 
                                                </p>
                                            </li>
                                            <li>
                                                <h3>Compuerta Mux</h3>
                                                <div class="info_compuerta">
                                                    <img src="https://i.ibb.co/fxp94zF/mux.png" alt="Mux">
                                                    <div class="codigo_compuerta">
                                                        <h4>Código:</h4>
    <pre>
    <code>
    CHIP Mux {
        IN a, b, sel;
        OUT out;

        PARTS:
        Not(in = sel, out = Nsel);
        And(a = Nsel, b = a, out = SA);
        And(a = sel, b = b, out = SB);
        Or(a = SA, b = SB, out = out);
    }   
    </code>
    </pre>
                                                    </div>
                                                </div>
                                                <p>En esta compuerta, además de tener dos entradas (a y b), se incluye un selector; si el selector tiene un nivel bajo, la salida
                                                    tendrá el nivel de la entrada a, pero si tiene un nivel alto, la salida tendrá el nivel de la entrada b. 
                                                    Otra forma de representarlo es utilizar 2 compuertas AND, en una se toman como entradas a y el selector negado, y en la otra 
                                                    a b con el selector, una vez obtenidas ambas salidas, estas se ingresan en una compuerta OR.
                                                </p>
                                            </li>
                                            <li>
                                                <h3>Compuerta Demux</h3>
                                                <div class="info_compuerta">
                                                    <img src="https://i.ibb.co/1fbYh5H/demux.png" alt="Demux">
                                                    <div class="codigo_compuerta">
                                                        <h4>Código:</h4>
    <pre>
    <code>
    CHIP DMux {
        IN in, sel;
        OUT a, b;

        PARTS:
        Not(in = sel, out = Nsel);
        And(a = in, b = Nsel, out = a);
        And(a = in, b = sel, out = b);
        
    }  
    </code>
    </pre>
                                                    </div>
                                                </div>
                                                <p>Esta compuerta tiene una entrada, un selector y dos salidas (a y b), si el selector tiene un nivel bajo, la salida a toma el nivel de 
                                                    la entrada y la salida b toma un nivel bajo, pero si el selector tiene un nivel alto, la salida a toma un nivel bajo y la salida b 
                                                    toma el nivel de la entrada. Otra forma de representarlo es utilizar una compuerta AND con la entrada y el selector negado para la 
                                                    salida a y otra compuerta AND con la entrada y el selector para la salida b.
                                                </p>
                                            </li>
                                            <li>
                                                <h3>Compuerta Not16</h3>
                                                <div class="info_compuerta">
                                                    <img src="https://i.ibb.co/RvYSmGR/not16.png" alt="Not16">
                                                    <div class="codigo_compuerta">
                                                        <h4>Código:</h4>
    <pre>
    <code>
    CHIP Not16 {
        IN in[16];
        OUT out[16];

        PARTS:
        Not(in = in[0], out = out[0]);
        Not(in = in[1], out = out[1]);
        Not(in = in[2], out = out[2]);
        Not(in = in[3], out = out[3]);
        Not(in = in[4], out = out[4]);
        Not(in = in[5], out = out[5]);
        Not(in = in[6], out = out[6]);
        Not(in = in[7], out = out[7]);
        Not(in = in[8], out = out[8]);
        Not(in = in[9], out = out[9]);
        Not(in = in[10], out = out[10]);
        Not(in = in[11], out = out[11]);
        Not(in = in[12], out = out[12]);
        Not(in = in[13], out = out[13]);
        Not(in = in[14], out = out[14]);
        Not(in = in[15], out = out[15]);
    }  
    </code>
    </pre>
                                                    </div>
                                                </div>
                                                <p>Esta compuerta consiste en un NOT, donde su entrada tiene una tamaño de 16 bits, por lo que se implementa la compuerta NOT 16 veces.</p>
                                            </li>
                                            <li>
                                                <h3>Compuerta AND16</h3>
                                                <div class="info_compuerta">
                                                    <img src="https://i.ibb.co/XWcWs0X/and16.png" alt="And16">
                                                    <div class="codigo_compuerta">
                                                        <h4>Código:</h4>
    <pre>
    <code>
    CHIP And16 {
        IN a[16], b[16];
        OUT out[16];

        PARTS:
        And(a = a[0], b = b[0], out = out[0]);
        And(a = a[1], b = b[1], out = out[1]);
        And(a = a[2], b = b[2], out = out[2]);
        And(a = a[3], b = b[3], out = out[3]);
        And(a = a[4], b = b[4], out = out[4]);
        And(a = a[5], b = b[5], out = out[5]);
        And(a = a[6], b = b[6], out = out[6]);
        And(a = a[7], b = b[7], out = out[7]);
        And(a = a[8], b = b[8], out = out[8]);
        And(a = a[9], b = b[9], out = out[9]);
        And(a = a[10], b = b[10], out = out[10]);
        And(a = a[11], b = b[11], out = out[11]);
        And(a = a[12], b = b[12], out = out[12]);
        And(a = a[13], b = b[13], out = out[13]);
        And(a = a[14], b = b[14], out = out[14]);
        And(a = a[15], b = b[15], out = out[15]);

    } 
    </code>
    </pre>
                                                    </div>
                                                </div>
                                                <p>Esta compuerta consiste en una AND, donde las entradas tienen un tamaño de 16 bits, por lo que se implementa la compuerta AND 16 veces
                                                    por cada bit de ambas entradas.
                                                </p>
                                            </li>
                                            <li>
                                                <h3>Compuerta OR16</h3>
                                                <div class="info_compuerta">
                                                    <img src="https://i.ibb.co/ydcs8pB/or16.png" alt="Or16">
                                                    <div class="codigo_compuerta">
                                                        <h4>Código:</h4>
    <pre>
    <code>
    CHIP Or16 {
        IN a[16], b[16];
        OUT out[16];

        PARTS:
        Or(a = a[0], b = b[0], out = out[0]);
        Or(a = a[1], b = b[1], out = out[1]);
        Or(a = a[2], b = b[2], out = out[2]);
        Or(a = a[3], b = b[3], out = out[3]);
        Or(a = a[4], b = b[4], out = out[4]);
        Or(a = a[5], b = b[5], out = out[5]);
        Or(a = a[6], b = b[6], out = out[6]);
        Or(a = a[7], b = b[7], out = out[7]);
        Or(a = a[8], b = b[8], out = out[8]);
        Or(a = a[9], b = b[9], out = out[9]);
        Or(a = a[10], b = b[10], out = out[10]);
        Or(a = a[11], b = b[11], out = out[11]);
        Or(a = a[12], b = b[12], out = out[12]);
        Or(a = a[13], b = b[13], out = out[13]);
        Or(a = a[14], b = b[14], out = out[14]);
        Or(a = a[15], b = b[15], out = out[15]);
    }
    </code>
    </pre>
                                                    </div>
                                                </div>
                                                <p>Esta compuerta consiste en una OR, donde las entradas tienen un tamaño de 16 bits, por lo que se implementa la compuerta OR 16 veces
                                                    por cada bit de ambas entradas.</p>
                                            </li>
                                            <li>
                                                <h3>Compuerta MUX16</h3>
                                                <div class="info_compuerta">
                                                    <img src="https://i.ibb.co/GPrPzGt/mux16.png" alt="Mux16">
                                                    <div class="codigo_compuerta">
                                                        <h4>Código:</h4>
    <pre>
    <code>
    CHIP Mux16 {
        IN a[16], b[16], sel;
        OUT out[16];

        PARTS:
        Mux(a = a[0], b = b[0], sel = sel, out = out[0]);
        Mux(a = a[1], b = b[1], sel = sel, out = out[1]);
        Mux(a = a[2], b = b[2], sel = sel, out = out[2]);
        Mux(a = a[3], b = b[3], sel = sel, out = out[3]);
        Mux(a = a[4], b = b[4], sel = sel, out = out[4]);
        Mux(a = a[5], b = b[5], sel = sel, out = out[5]);
        Mux(a = a[6], b = b[6], sel = sel, out = out[6]);
        Mux(a = a[7], b = b[7], sel = sel, out = out[7]);
        Mux(a = a[8], b = b[8], sel = sel, out = out[8]);
        Mux(a = a[9], b = b[9], sel = sel, out = out[9]);
        Mux(a = a[10], b = b[10], sel = sel, out = out[10]);
        Mux(a = a[11], b = b[11], sel = sel, out = out[11]);
        Mux(a = a[12], b = b[12], sel = sel, out = out[12]);
        Mux(a = a[13], b = b[13], sel = sel, out = out[13]);
        Mux(a = a[14], b = b[14], sel = sel, out = out[14]);
        Mux(a = a[15], b = b[15], sel = sel, out = out[15]);
    }
    </code>
    </pre>
                                                    </div>
                                                </div>
                                                <p>Esta compuerta consiste de un MUX donde ambas entradas tienen un tamaño de 16 bits con un mismo selector compartido,
                                                    la salida también tiene un tamaño de 16 bits, donde cada bit será obtenido a través del uso de la compuerta MUX entre cada pixel
                                                    de ambas entradas junto al selector.
                                                </p>
                                            </li>
                                            <li>
                                                <h3>Compuerta OR8WAY</h3>
                                                <div class="info_compuerta">
                                                    <img src="https://i.ibb.co/rw5vP3s/or8way.png" alt="Or8way">
                                                    <div class="codigo_compuerta">
                                                        <h4>Código:</h4>
    <pre>
    <code>
    CHIP Or8Way {
        IN in[8];
        OUT out;

        PARTS:
        Or(a=in[0],b=in[1],out=a);
        Or(a=a,b=in[2],out=b);
        Or(a=b,b=in[3],out=c);
        Or(a=c,b=in[4],out=d);
        Or(a=d,b=in[5],out=e);
        Or(a=e,b=in[6],out=f);
        Or(a=f,b=in[7],out=out);
    }
    </code>
    </pre>
                                                    </div>
                                                </div>
                                                <p>Esta compuerta es un OR entre los 8 bits de una entrada, la cual su salida tendrá un nivel alto si alguno de estos bits tiene
                                                    un nivel alto.
                                                </p>
                                            </li>
                                            <li>
                                                <h3>Compuerta MUX4WAY16</h3>
                                                <div class="info_compuerta">
                                                    <img src="https://i.ibb.co/BTpjd2p/mux4way16.png" alt="MUX4WAY16">
                                                    <div class="codigo_compuerta">
                                                        <h4>Código:</h4>
    <pre>
    <code>
    CHIP Mux4Way16 {
        IN a[16], b[16], c[16], d[16], sel[2];
        OUT out[16];

        PARTS:
        Mux16(a=a,b=b,sel=sel[0],out=q); 
        Mux16(a=c,b=d,sel=sel[0],out=r);
        Mux16(a=q,b=r,sel=sel[1],out=out);
    }
    </code>
    </pre>
                                                    </div>
                                                </div>
                                                <p>Esta compuerta consiste en un multiplexor con 4 entradas de 16 bits cada una. Debido a que son 4 entradas, el selector
                                                    debe ser de dos bits para cubrir todas estas. Para esto se utilizan 2 compuertas MUX16 entre las entradas a y b y las entradas c y d,
                                                    en estas se utiliza el primer bit del selector, posteriormente se toman ambas salidas y se realiza otro MUX16 entre ellas, tomando el 
                                                    segundo bit del selector.
                                                </p>
                                            </li>
                                            <li>
                                                <h3>Compuerta MUX8WAY16</h3>
                                                <div class="info_compuerta">
                                                    <img src="https://i.ibb.co/3SF0Tz8/mux8way16.png" alt="MUX8WAY16">
                                                    <div class="codigo_compuerta">
                                                        <h4>Código:</h4>
    <pre>
    <code>
    CHIP Mux8Way16 {
        IN a[16], b[16], c[16], d[16],
        e[16], f[16], g[16], h[16],
        sel[3];
        OUT out[16];

        PARTS:
        Mux16(a = a,b = b,sel = sel[0],out = q); 
        Mux16(a = c,b = d,sel = sel[0],out = r);
        Mux16(a = e,b = f,sel = sel[0],out = s); 
        Mux16(a = g,b = h,sel = sel[0],out = t);
        Mux16(a = q,b = r,sel = sel[1],out = y);
        Mux16(a = s,b = t,sel = sel[1],out = z);
        Mux16(a = y,b = z,sel = sel[2],out = out);
    }
    </code>
    </pre>
                                                    </div>
                                                </div>
                                                <p>Esta compuerta consiste en un multiplexor con 8 entradas de 16 bits cada una. Debido a que son 8 entradas, el selector
                                                    debe ser de tres bits para cubrir todas estas. Para esto se utilizan 4 compuertas MUX16 entre las entradas a, b, c, d, e, f,
                                                    g y h, se toman las 4 salidas obtenidas y se realizan otros 2 MUX16 entre ellas, con el segundo bit del selector, finalmente
                                                    se hace un último MUX16 entre ambas salidas, junto al tercer bit del selector,</p>
                                            </li>
                                            <li>
                                                <h3>Compuerta DMUX4WAY</h3>
                                                <div class="info_compuerta">
                                                    <img src="https://i.ibb.co/MgG1fPF/DMUX4WAY.png" alt="DMUX4WAY">
                                                    <div class="codigo_compuerta">
                                                        <h4>Código:</h4>
    <pre>
    <code>
    CHIP DMux4Way {
        IN in, sel[2];
        OUT a, b, c, d;

        PARTS:
        DMux(in=in,sel=sel[1],a=A,b=B);
        DMux(in=A,sel=sel[0],a=a,b=b);
        DMux(in=B,sel=sel[0],a=c,b=d);
    }
    </code>
    </pre>
                                                    </div>
                                                </div>
                                                <p>Esta compuerta consiste en un DMUX, pero con 4 salidas. Debido a las cantidad de salidas, el selector tendrá dos bits. Para esto se
                                                    inicia con un DMUX utilizando el segundo bit del selector, para cada salida se le aplicará otro DMUX usando el primer bit del selector,
                                                    en el cual se obtendrán las 
                                                    4 salidas mencionadas.
                                                </p>
                                            </li>
                                            <li>
                                                <h3>Compuerta DMUX8WAY</h3>
                                                <div class="info_compuerta">
                                                    <img src="https://i.ibb.co/g7fWGNP/DMUX8WAY.png" alt="DMUX8WAY">
                                                    <div class="codigo_compuerta">
                                                        <h4>Código:</h4>
    <pre>
    <code>
    CHIP DMux8Way {
        IN in, sel[3];
        OUT a, b, c, d, e, f, g, h;

        PARTS:
        DMux(in=in,sel=sel[2],a=A,b=B);
        DMux(in=A,sel=sel[1],a=C,b=D);
        DMux(in=B,sel=sel[1],a=F,b=G);
        DMux(in=C,sel=sel[0],a=a,b=b);
        DMux(in=D,sel=sel[0],a=c,b=d);
        DMux(in=F,sel=sel[0],a=e,b=f);
        DMux(in=G,sel=sel[0],a=g,b=h);
    }
    </code>
    </pre>
                                                    </div>
                                                </div>
                                                <p>Esta compuerta consiste en un DMUX, pero con 8 salidas. Debido a las cantidad de salidas, el selector tendrá tres bits. Para esto se
                                                    inicia con un DMUX utilizando el tercer bit del selector, para cada salida se le aplicará otro DMUX con el segundo bit del selector,
                                                    para cada una de las 4 salidas de estos 2 DMUX, se le aplica un último DMUX con el primer bit del selector, obteniendo las 8 salidas
                                                    pedidas.
                                                </p>
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        <h4>Responder la pregunta planteada en clase:</h4>
                                        <div class="imagenes_respuesta">
                                            <img src="https://i.ibb.co/dMs2hnw/pregunta1.png" alt="Respuesta1">
                                        </div>
                                    </li>
                                </ol>
                            </div>
                        </div>
                    </article>
                </details>
                <details>
                    <summary>Práctica 3: Aritmética Booleana Y Lógica Secuencial</summary>
                    <article class="practica">
                    <div class="titulo_practica">
                        <h2>Práctica 3: Aritmética Booleana Y Lógica Secuencial</h2>
                    </div>
                    <div class="descripcion_practica">
                        <p>Ahora es tiempo de realizar el proyecto 2, denominado Lógica Aritmética, que puede encontrar en:
                             <a href="https://www.nand2tetris.org/project02">https://www.nand2tetris.org/project02</a>  y el proyecto 3, denominado Lógica secuencial, se trataran
                              aspectos importantes relacionados con la memoria y se puede encontrar en: <a href="https://www.nand2tetris.org/project03">https://www.nand2tetris.org/project03</a> </p>
                    </div>
                    <div class="desarrollo_practica">
                        <div class="informe">
                            <div class="video_informe">
                                <iframe width="560" height="315" src="https://www.youtube.com/embed/ptmjhqVJwKI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                                <p>El caso de no cargar el video, puede darle click <a href="https://www.youtube.com/watch?v=ptmjhqVJwKI" target="_blank"> Aqui</a></p>
                            </div>
                            <ol>
                                <li>
                                    <h4>¿Cuál es el objetivo de cada uno de esos proyectos con sus palabras y describa que debe hacer para desarrollarlo?</h4>
                                    <p>El objetivo de este proyecto consiste en continuar la construcción de una computadora, precisamente
                                        en la construcción de la CPU (Project 2 de Nandtetris) y de la RAM (Project 3 de Nandtetris) mediante el uso de los chips
                                        creados en el projecto 2 junto a nuevos diferentes chips que
                                        ayudarán en la creación progresiva de chips más complejos, tales como el ALU o la RAM116K.
                                    </p>
                                </li>
                                <li>
                                    <h4>Construir las compuertas solicitadas y documentar los resultados:</h4>
                                    <h2>Project 2:</h2>
                                    <ul>
                                        <li>
                                            <h3>Compuerta HalfAdder</h3>
                                            <div class="info_compuerta">
                                                <img src="https://i.ibb.co/jMhX3fR/halfadder.png" alt="HalfAdder">
                                                <div class="codigo_compuerta">
                                                    <h4>Codigo:</h4>
<pre>
    <code>
CHIP HalfAdder {
    IN a, b;    // 1-bit inputs
    OUT sum,    // Right bit of a + b 
        carry;  // Left bit of a + b

    PARTS:
    Xor(a = a, b = b, out=sum);
    And(a = a, b = b, out=carry);
}
    </code>
</pre>
                                                </div>
                                            </div>
                                            <p>Esta compuerta permite realizar la suma de 2 bits, pero sin recibir un bit de acarreo,
                                                 en otras palabras, esta compuerta suma dos bits sin haber realizado una suma anterior, 
                                                 entregando el resultado de la suma y un bit de acarreo.
                                            </p>
                                        </li>
                                        <li>
                                            <h3>Compuerta FullAdder</h3>
                                            <div class="info_compuerta">
                                                <img src="https://i.ibb.co/Kq5jsSm/fulladder.png" alt="FullOAdder">
                                                <div class="codigo_compuerta">
                                                    <h4>Codigo:</h4>
<pre>
    <code>
CHIP FullAdder {
    IN a, b, c;  // 1-bit inputs
    OUT sum,     // Right bit of a + b + c
        carry;   // Left bit of a + b + c

    PARTS:
    Not(in = a, out = Na);
    Xor(a = b, b = c, out = bcXor);
    Not(in = bcXor, out = bcExnor);
    And(a = Na, b = bcXor, out = And1);
    And(a = a, b = bcExnor, out = And2);
    Or(a = And1, b = And2, out = sum);

    And(a = a, b = c, out = ac);
    And(a = b, b = a, out = ba);
    And(a = b, b = c, out = bc);
    Or(a = ac, b = ba, out = halfOr);
    Or(a = halfOr, b = bc, out = carry);
}
    </code>
</pre>
                                                </div>
                                            </div>
                                            <p>Esta compuerta complementa la compuerta anterior, debido a que también representa la suma de dos bits, 
                                                pero con la característica de aceptar un bit acarreado de valor de entrada, retornando el bit sumado y 
                                                el nuevo bit acarreado obtenido.
                                            </p>
                                        </li>  
                                        <li>
                                            <h3>Compuerta Add16</h3>
                                            <div class="info_compuerta">
                                                <img src="https://i.ibb.co/ZH7kw8c/add16.png" alt="Add16">
                                                <div class="codigo_compuerta">
                                                    <h4>Codigo:</h4>
<pre>
    <code>
CHIP Add16 {
    IN a[16], b[16];
    OUT out[16];

    PARTS:
    HalfAdder(a = a[0], b = b[0], sum = out[0], carry = c);
    FullAdder(a = a[1], b = b[1], c = c, sum = out[1], carry = d);
    FullAdder(a = a[2], b = b[2], c = d, sum = out[2], carry = e);
    FullAdder(a = a[3], b = b[3], c = e, sum = out[3], carry = f);
    FullAdder(a = a[4], b = b[4], c = f, sum = out[4], carry = g);
    FullAdder(a = a[5], b = b[5], c = g, sum = out[5], carry = h);
    FullAdder(a = a[6], b = b[6], c = h, sum = out[6], carry = i);
    FullAdder(a = a[7], b = b[7], c = i, sum = out[7], carry = j);
    FullAdder(a = a[8], b = b[8], c = j, sum = out[8], carry = k);
    FullAdder(a = a[9], b = b[9], c = k, sum = out[9], carry = l);
    FullAdder(a = a[10], b = b[10], c = l, sum = out[10], carry = m);
    FullAdder(a = a[11], b = b[11], c = m, sum = out[11], carry = n);
    FullAdder(a = a[12], b = b[12], c = n, sum = out[12], carry = o);
    FullAdder(a = a[13], b = b[13], c = o, sum = out[13], carry = p);
    FullAdder(a = a[14], b = b[14], c = p, sum = out[14], carry = q);
    FullAdder(a = a[15], b = b[15], c = q, sum = out[15], carry = lost);
}
    </code>
</pre>
                                                </div>
                                            </div>
                                            <p>Esta compuerta representa la suma de dos números A y B de 16 bits, por lo que se inicia con un HalfAdder entre los primeros bits, debido a que es la
                                                 primera cifra sumada, posteriormente se realizan FullAdders a los demás bits, tomando como bit acarreador el bit acarreador obtenido del anterior bit, 
                                                 el último bit acarreado se ignora.
                                            </p>
                                        </li>    
                                        <li>
                                            <h3>Compuerta Inc16</h3>
                                            <div class="info_compuerta">
                                                <img src="https://i.ibb.co/xYQ3Vh9/inc16.png" alt="Inc16">
                                                <div class="codigo_compuerta">
                                                    <h4>Codigo:</h4>
<pre>
    <code>
CHIP Inc16 {
    IN in[16];
    OUT out[16];

    PARTS:
    Add16(a = in, b[0] = true, out = out);
}
    </code>
</pre>
                                                </div>
                                            </div>
                                            <p>La compuerta es la suma de un bit a cada bit de un número de 16 bits.</p>
                                        </li> 
                                        <li>
                                            <h3>Compuerta ALU</h3>
                                            <div class="info_compuerta">
                                                <img src="https://i.ibb.co/XsTGzTc/alu.png" alt="Alu">
                                                <div class="codigo_compuerta">
                                                    <h4>Codigo:</h4>
<pre>
    <code>
CHIP ALU {
    IN  
        x[16], y[16],  // 16-bit inputs        
        zx, // zero the x input?
        nx, // negate the x input?
        zy, // zero the y input?
        ny, // negate the y input?
        f,  // compute out = x + y (if 1) or x & y (if 0)
        no; // negate the out output?

    OUT 
        out[16], // 16-bit output
        zr, // 1 if (out == 0), 0 otherwise
        ng; // 1 if (out < 0),  0 otherwise

    PARTS:
   Mux16(a = x, b[0..15] = false, sel = zx, out = Zerox);
   Not16(in = Zerox, out = Notx);
   Mux16(a = Zerox, b = Notx, sel = nx, out = Mx);
   Mux16(a = y, b[0..15] = false, sel = zy, out = Zeroy);
   Not16(in = Zeroy, out = Noty);
   Mux16(a = Zeroy, b = Noty, sel = ny, out = My);

   Add16(a = Mx, b = My, out = xmy);
   And16(a = Mx, b = My, out = xay);
   Mux16(a = xay, b = xmy, sel = f, out = fout);

   Not16(in = fout, out = nfout);
   Mux16(a = fout, b = nfout, sel = no, out = lout);

   And16(a[0..15]=true,b=lout,out[0..7]=lout1);
   And16(a[0..15]=true,b=lout,out[0..7]=lout2);
   Or8Way(in = lout1, out=Zerout1);
   Or8Way(in = lout2, out=Zerout2);
   Or(a = Zerout1, b = Zerout2, out = Zerout);
   Not(in = Zerout, out = zr);

   And16(a[0..15]=true,b=lout,out[15]=ng,out[0..14]=lost);

   Or16(a=lout,b[0..15]=false,out=out); 
}
    </code>
</pre>
                                                </div>
                                            </div>
                                            <p>Es la compuerta central del procesador, permite realizar varias operaciones entre dos números de 16 bits, tales como igualarlos a 0, 
                                                negarlos, sumarlos o conjugarlos dependiendo de un input, negar dicho resultado, etc.
                                            </p>
                                        </li> 
                                    </ul>
                                    <h2>Project 3:</h2>
                                    <ul>
                                        <li>
                                            <h3>Compuerta BIT</h3>
                                            <div class="info_compuerta">
                                                <img src="https://i.ibb.co/myJGb40/image-2021-11-29-202819.png" alt="Bit">
                                                <div class="codigo_compuerta">
                                                    <h4>Codigo:</h4>
<pre>
    <code>
CHIP Bit {
    IN in, load;
    OUT out;

    PARTS:
    Mux(a = dout ,b = in ,sel = load, out = mout);
    DFF(in = mout, out = out, out = dout);
}
    </code>
</pre>
                                                </div>
                                            </div>
                                            <p>Esta compuerta consiste en el almacenamiento de un bit de información, para esto se utiliza un flip-flop tipo D y una compuerta MUX, 
                                                el flip-flop se utiliza para almacenar el valor actualizado del bit, mientras que la compuerta MUX se encarga de actualizar el valor a 
                                                base de su selector y el nuevo dato "in", si el selector es 1, el valor almacenado pasará a ser "in", pero si este es 0, se mantendrá el 
                                                dato almacenado.
                                            </p>
                                        </li> 
                                        <li>
                                            <h3>Compuerta REGISTER</h3>
                                            <div class="info_compuerta">
                                                <img src="https://i.ibb.co/3RXZZB2/register.png" alt="Register">
                                                <div class="codigo_compuerta">
                                                    <h4>Codigo:</h4>
<pre>
    <code>
CHIP Register {
    IN in[16], load;
    OUT out[16];

    PARTS:
    Bit(in = in[0], load = load, out = out[0]);
    Bit(in = in[1], load = load, out = out[1]);
    Bit(in = in[2], load = load, out = out[2]);
    Bit(in = in[3], load = load, out = out[3]);
    Bit(in = in[4], load = load, out = out[4]);
    Bit(in = in[5], load = load, out = out[5]);
    Bit(in = in[6], load = load, out = out[6]);
    Bit(in = in[7], load = load, out = out[7]);
    Bit(in = in[8], load = load, out = out[8]);
    Bit(in = in[9], load = load, out = out[9]);
    Bit(in = in[10], load = load, out = out[10]);
    Bit(in = in[11], load = load, out = out[11]);
    Bit(in = in[12], load = load, out = out[12]);
    Bit(in = in[13], load = load, out = out[13]);
    Bit(in = in[14], load = load, out = out[14]);
    Bit(in = in[15], load = load, out = out[15]);
}
    </code>
</pre>
                                                </div>
                                            </div>
                                            <p>La compuerta REGISTER funciona de la misma manera que el BIT, pero en este caso, se almacenan un total de 16 bits, es decir, 16 compuertas
                                                BIT por cada bit.
                                            </p>
                                        </li> 
                                        <li>
                                            <h3>Compuerta RAM8</h3>
                                            <div class="info_compuerta">
                                                <img src="https://i.ibb.co/cctPBHs/ram8.png" alt="Ram8">
                                                <div class="codigo_compuerta">
                                                    <h4>Codigo:</h4>
<pre>
    <code>
CHIP RAM8 {
    IN in[16], load, address[3];
    OUT out[16];

    PARTS:
    DMux8Way(in=load,sel=address,a=a,b=b,c=c,d=d,e=e,f=f,g=g,h=h);
    Register(in=in,load=a,out=ra);
    Register(in=in,load=b,out=rb);
    Register(in=in,load=c,out=rc);
    Register(in=in,load=d,out=rd);
    Register(in=in,load=e,out=re);
    Register(in=in,load=f,out=rf);
    Register(in=in,load=g,out=rg);
    Register(in=in,load=h,out=rh);

    Mux8Way16(a = ra, b = rb, c = rc, d = rd, e = re,
     f = rf, g = rg, h = rh, sel = address, out = out);
}
    </code>
</pre>
                                                </div>
                                            </div>
                                            <p>Consiste en una memoria de 8 registros, cada una de un largo de 16 bits, la salida contiene un valor almacenado en una ubicación 
                                                especificada por una dirección, si el valor load es 1, el valor de "in" se almacenará el la dirección especificada, retornandola en
                                                la salida out.
                                            </p>
                                        </li> 
                                        <li>
                                            <h3>Compuerta RAM64</h3>
                                            <div class="info_compuerta">
                                                <img src="https://i.ibb.co/QKLw1Sq/ram64.png" alt="Ram64">
                                                <div class="codigo_compuerta">
                                                    <h4>Codigo:</h4>
<pre>
    <code>
CHIP RAM64 {
    IN in[16], load, address[6];
    OUT out[16];

    PARTS:
    DMux8Way(in=load,sel=address[3..5],a=a,b=b,c=c,d=d,e=e,f=f,g=g,h=h);

    RAM8(in = in, load = a, address = address[0..2], out = ra);
    RAM8(in = in, load = b, address = address[0..2], out = rb);
    RAM8(in = in, load = c, address = address[0..2], out = rc);
    RAM8(in = in, load = d, address = address[0..2], out = rd);
    RAM8(in = in, load = e, address = address[0..2], out = re);
    RAM8(in = in, load = f, address = address[0..2], out = rf);
    RAM8(in = in, load = g, address = address[0..2], out = rg);
    RAM8(in = in, load = h, address = address[0..2], out = rh);

    Mux8Way16(a=ra,b=rb,c=rc,d=rd,e=re,f=rf,
    g=rg,h=rh,sel=address[3..5],out=out);
}
    </code>
</pre>
                                                </div>
                                            </div>
                                            <p>Esta compuerta es similar a la anterior, solo que en vez de 8 registros, son 64, por lo que en vez de utilizar 64 registers, 
                                                se pueden utilizar 8 RAM8 en su lugar, debido al aumento de registros, también aumenta el número de bits para la dirección (6 bits).
                                            </p>
                                        </li>
                                        <li>
                                            <h3>Compuerta RAM512</h3>
                                            <div class="info_compuerta">
                                                <img src="https://lh3.googleusercontent.com/guN-Y6Pk7D_gEAexhux2QD10rVmsf8i2mV6kdos4CyMQUiscv-2lT5EFUlspe2ZWsAqymQM8-fa_X3FjKM9kLkYG1LI04p5vO1qtj-RsLdH0AiozND69GIKIFKOdZQLKEhaTL2raE7FXqL3Bz2RQ-ZOeJt2Bh91sZ6pZiCIH3Ao-NQ5O6nDQcVLc-NyzDurm11lWRqxcn2kIsSuJmko8UjBUyOXf6CoKN9978zMjpuRWgYwwm97mnDnC_dFUiG9oYaS_yN35vqZ1RmnIEPFaiHOTxNFPFkiHIkhtdj1X7bqFiyvubUyG2MyqTuEYZgNqbGlfyjnoYICa1sF8Po5epD59Vd5Pg8cJVkttuqwbppF153QXC7PQUUp6xFCCumtLwRBuwkTRBf8uJv1o5zbRG3fZtWhj65ciP-vDkjURFYcNXhe7DqNwkQzUyWDiDt61uSkNtji2bQ5K7IM2B6R-KoR5Vq1pD89jS2v31dVV4RXh9naLeoTXQi1CsdZxK64JGMedMEq1krpgQAbjKMTmX0jiu5NSXTg8yRhsLo2Ieb1UQRTOYlqorPBAPRG12qam5Y0sYx4pdu4-zeZqrOELeErdIXBu5liPZV4yjb2EY5pXvZSHrsm4Cv5I55NezsJgDatuNzlJofIuQvrC1l8MbJcOGpB2DPEcz7xVksv-qI3_YqgyKS-qzqfdYHo1dzswDAc54XMRgas6g9ScbWmeQzUt=w281-h480-no?authuser=0" alt="Ram512">
                                                <div class="codigo_compuerta">
                                                    <h4>Codigo:</h4>
<pre>
    <code>
CHIP RAM512 {
    IN in[16], load, address[9];
    OUT out[16];

    PARTS:
    DMux8Way(in=load,sel=address[6..8],a=a,b=b,c=c,d=d,e=e,f=f,g=g,h=h);

    RAM64(in = in, load = a, address = address[0..5], out = ra);
    RAM64(in = in, load = b, address = address[0..5], out = rb);
    RAM64(in = in, load = c, address = address[0..5], out = rc);
    RAM64(in = in, load = d, address = address[0..5], out = rd);
    RAM64(in = in, load = e, address = address[0..5], out = re);
    RAM64(in = in, load = f, address = address[0..5], out = rf);
    RAM64(in = in, load = g, address = address[0..5], out = rg);
    RAM64(in = in, load = h, address = address[0..5], out = rh);

    Mux8Way16(a=ra,b=rb,c=rc,d=rd,e=re,
    f=rf,g=rg,h=rh,sel=address[6..8],out=out);
}
    </code>
</pre>
                                                </div>
                                            </div>
                                            <p>Esta compuerta es similar a la anterior, solo que en vez de 64 registros, son 512, por lo que en vez de utilizar 512 registers, 
                                                se pueden utilizar 8 RAM64 en su lugar, debido al aumento de registros, también aumenta el número de bits para la dirección (9 bits).</p>
                                        </li> 
                                        <li>
                                            <h3>Compuerta RAM4K</h3>
                                            <div class="info_compuerta">
                                                <img src="https://lh3.googleusercontent.com/CFc_40-1zmH1LfNQMBkhUNq_y6Klledxyz6RKFVf1I56JW8srE-sNdZ9Ut_9qo-oovCio6SWNthj5Q7_VNbNP0BiqfB1g1N3_542A389oGAa5eeRxTqSZcXhPdNkmDfWovWFBlIOFqsBfiudGoVMqtkbg2l9xPjeJ9rxvx5WeeAGpj3TWajCOEePAbPlAFRagMg_cQNfj-LTP00PGN0-NpuK3qqqXzCSlsOo_LZwkSTm5JIEpjvxHXWcNhbXtyJkH4aOC1OiR3QSe7OuHD8GfRvn3jKFKZfg41tOceKdghHtsO_qgRgL9-Lf7XmfMXXL0dyPijYJ8pMs3HQ1Luss5CBM-hBz4TwTJ5-MUBqFmUtQTfxapONO0TkhrnEtfkHPxX8cinA6hcnDcADTqHZhJ4ij5fOGPYgxIpgmRHLI4S-kN7-JBRnUzvG5pToUEWCKiBX0B06cdxfMMFM1OthrJMTORaPgKJjQM9GVZxIirMNxXEApT68shDjsT0nvFpOD3GZPHhhE96_jnBDSwTLrxKUwZMI9ByFKd_hKnhn9tkJHgLTsjLmQEBzDGiZMi2ERzRrai5EbiIEARegzgge3ITXHZJvda1A8ZqA2YBetcLsreegr3oFpok4h7HqkxhSQb6NwQr_CQG-gNDJ01hThxLSqfJr2c8vPkqGQUvjISFnV8LT_35xyLfQszrSgJkYlf5RzR8UjblQXWNHEB4sM69xN=w281-h480-no?authuser=0" alt="Ram4K">
                                                <div class="codigo_compuerta">
                                                    <h4>Codigo:</h4>
<pre>
    <code>
CHIP RAM4K {
    IN in[16], load, address[12];
    OUT out[16];

    PARTS:
    DMux8Way(in=load,sel=address[9..11],a=a,b=b,c=c,d=d,e=e,f=f,g=g,h=h);

    RAM512(in = in, load = a, address = address[0..8], out = ra);
    RAM512(in = in, load = b, address = address[0..8], out = rb);
    RAM512(in = in, load = c, address = address[0..8], out = rc);
    RAM512(in = in, load = d, address = address[0..8], out = rd);
    RAM512(in = in, load = e, address = address[0..8], out = re);
    RAM512(in = in, load = f, address = address[0..8], out = rf);
    RAM512(in = in, load = g, address = address[0..8], out = rg);
    RAM512(in = in, load = h, address = address[0..8], out = rh);

    Mux8Way16(a=ra,b=rb,c=rc,d=rd,e=re,f=rf,
    g=rg,h=rh,sel=address[9..11],out=out);
}
    </code>
</pre>
                                                </div>
                                            </div>
                                            <p>>Esta compuerta es similar a la anterior, solo que en vez de 512 registros, son 4096, por lo que en vez de utilizar 4096 registers, 
                                                se pueden utilizar 8 RAM512 en su lugar, debido al aumento de registros, también aumenta el número de bits para la dirección (12 bits).</p>
                                        </li> 
                                        <li>
                                            <h3>Compuerta RAM16K</h3>
                                            <div class="info_compuerta">
                                                <img src="https://lh3.googleusercontent.com/2wUxwVgHtpF3KgZVbvKIPS25RbnKHryw7uzqdB3F4XrcLARvK_cEGiepvJPWzo77wFWlRfiFOnKgtwfLgvDYwSvxphFYylhQs7BwldM_nlHaFw5INn9xiQLntmu4qTD6mFwIqyAV9Lz873tVufGNB2l7JLySUdS4LZPQDAVOVCq4i61cWHjqGRpMorAzOzvxjH6HXOQNb72-rJT2c2x7o_R-JPubfzjHZ0ndMTlxHcr__uX6N5GxVHLpuk9q3AUy5F-RrduVJlADPtxnrSqesaDfsaYvSIEzg7sAmM7VSAGMdQytmNYDB-S4D7DH9JwWfKTC0YVKFgLjxLoQkmm8FBqxMnUknCcHazbIbf7FsBXhno2I4U3fzsxpCNTH3Kq4TZP3-DG_btpuFxzVf4Kzx4UCfFWjYCQw3PG6BS8-QfVd0DG8OJTnmKXWwgMfrqvLdhLSyE3sEdqCQ0c--WXy_9T5lj792Jx9a_mVdt3tO1taw3sefpWQ8_K3dnNZZPrQA8LvSIpjNXkCCUxDfCV9VFmNNa_esQRfFvDmFWCnAmv6JZ-cje5oJpCbgOvyYgeGAXRf1kuRdNIaJd27pi4zYAGhaWb4LlNvU4eI5eT5YhS6H7Ia2zkoG8tIeO-TIREUUEvPdUjkmwI2MU1288wq9yxzcSMxAL7vzX24Hw3XveMXFo5lbyDwlo5fT2oMz2b6CuUDiBaoqrC5ladQ4egImFdQ=w281-h480-no?authuser=0    " alt="Ram16K">
                                                <div class="codigo_compuerta">
                                                    <h4>Codigo:</h4>
<pre>
    <code>
CHIP RAM16K {
    IN in[16], load, address[14];
    OUT out[16];

    PARTS:
    DMux4Way(in=load,sel=address[12..13],a=a,b=b,c=c,d=d);

    RAM4K(in = in, load = a, address = address[0..11], out = ra);
    RAM4K(in = in, load = b, address = address[0..11], out = rb);
    RAM4K(in = in, load = c, address = address[0..11], out = rc);
    RAM4K(in = in, load = d, address = address[0..11], out = rd);

    Mux4Way16(a=ra,b=rb,c=rc,d=rd, sel=address[12..13],out=out);
}
    </code>
</pre>
                                                </div>
                                            </div>
                                            <p>Esta compuerta es similar a la anterior, solo que en vez de 4096 registros, son 16384, por lo que en vez de utilizar 16384 registers, 
                                                se pueden utilizar 4 RAM4K en su lugar, debido al aumento de registros, también aumenta el número de bits para la dirección (14 bits).</p>
                                        </li> 
                                        <li>
                                            <h3>Compuerta PC</h3>
                                            <div class="info_compuerta">
                                                <img src="https://lh3.googleusercontent.com/54Sph0n2IvIR5cMOTyNVcPCwVdoM5T6PHuxJgH0up1Pzhu8VvcqvrZJngOi06cEqqnjySfAGlGcJgudNC2WnSIYzJVZ1FVW497UjTLZcL1z7NWpPfg3SvzgyIX8ivkf49GfTWAujADZapOfPlRogB5xOa2jJ2paVqJtBB_zh9tYoE7qidU3md2k7dX74Akc6wBEClc5U0kz2kjwCvfiUlGriInwBwyqDnfPDRt4PSPHRDN8ShAlVGgQWdcYbUgIFb1ge5Cv7EOMcTFbkDb5uu9uVfEeHTr7oE28zZWuw3KH-WfIhpbu4r99s7Q5GfUSIEQSfJL0kJrY1MP51pdAX7USeoycETQUld8gb16B-QsqTi5FPN2hp0wCalqGfwsJtcNLqQKFqSR9OCEUCIZBNYqMongadDe-Fvw57Y5R_xdv6eJbjIVYbqnDiYBNcKuyJ83sOL645F8WrfumDwVADULyZNmGVZ3tx0PKv11LrlCr1s1d54S6yBGtcmkFYtlV-A1-9sgPOpkRx8Q3Ym05fXn6RtCz4sIGj-f391_yyscXxHa_fE_paNXoRJ6NjPXIB1QQK6r7M3qr3j-P6KPTrLkoCQ2ogLQnHLj1EmNMvJqXAQ99lfDLEnlLgyF16cshh-oiWCyTx4BIYtdSgPTZZKX9kV9E74jYyCb1PHP5cUicJp1jyukfvCNpSmTG67JIuYyS9Hfn9Y3TQFYfkEfZmzD5h=w454-h940-no?authuser=0" alt="Pc">
                                                <div class="codigo_compuerta">
                                                    <h4>Codigo:</h4>
<pre>
    <code>
CHIP PC {
    IN in[16],load,inc,reset;
    OUT out[16];

    PARTS:
    Inc16(in=oo,out=incd);

    Mux16(a=oo,b=incd,sel=inc,out=o);

    Mux16(a=o,b=in,sel=load,out=uu);

    Mux16(a=uu,b[0..15]=false,sel=reset,out=this);
    
    Register(in=this,load=true,out=out,out=oo);
}
    </code>
</pre>
                                                </div>
                                            </div>
                                            <p>El pc consiste en un contador de 16 bits, en el cual, mediante multiples MUX16 se podrá vovlerla 0, dejarla igual, sumarle uno, o reiniciar el conteo; 
                                                para posteriormente guardar el valor decidido mediante el REGISTER.
                                            </p>
                                        </li> 
                                    </ul>
                                </li>
                                <li>
                                    <h3>Responda la pregunta planteada en clase</h3>
                                    <p>Una empresa de transmisión de noticias ciudadanas, quiere aumentar la calidad de 
                                        transmisión de sus noticias de manera simultanea sobre diferentes plataformas, 
                                        tanto. de redes sociales como plataformas de streaming como youtube, vimeo y dailymotion.
                                         Para ello, deciden contratar servicios de al menos 250Mb de transmision. Teniendo en cuenta que en promedio,
                                          transmitiran tres programas simultaneos, para ser transmitidas en al menos 3 redes sociales y 2 plataformas de
                                           videostreaming, los propietarios les consultan a ustedes:</p>
                                           <h4>¿Que requerimientos funcionales se presentan?</h4>
                                           <ul>
                                                <li>● Listar programación del día</li>
                                                <li>● Listar programación del día</li>
                                                <li>● Listar plataformas en las que se puede acceder a cada programa</li>
                                                <li>● Acceder a los link de las plataformas de streaming</li>
                                                <li>● Activar notificaciones al inicio de los programas deseados</li>
                                                <li>● Capacidad de transmitir en TV</li>
                                                <li>● Consultar estadísticas de views de los programas</li>
                                                <li>● Consultar tabla de calidad vs capacidad de internet</li>
                                           </ul>
                                           <h4>¿Cuales son los limites que yo tengo?</h4>
                                           <ul>
                                                <li>● Puede ver únicamente un programa al tiempo en un dispositivo</li>
                                                <li>● Solamente lista los programas del día actual</li>
                                                <li>● Solo tiene 1 idioma disponible</li>
                                                <li>● No hay servicio de subtítulos</li>
                                                <li>● No tiene un control de calidad de imagen ni velocidad de reproducción</li>
                                           </ul>
                                           <h4>¿Cuales son tanto las médidas como las métricas para conocer la calidad del servicio? </h4>
                                           <h5>Métricas</h5>
                                           <ul>
                                                <li>● Una buena velocidad de internet permite tener una buena calidad de imagen.</li>   
                                                <li>● Una buena velocidad de internet permite tener una buena calidad de velocidad en reproducción.</li>
                                                <li>● Un buen uso del software puede permitir al usuario tener estadísticas muy funcionales como lo son las notificaciones de sugerencia y los programas más vistos</li>
                                           </ul>
                                           <h5>Medidas</h5>
                                           <ul>
                                                <li>● Se necesitan 250 Mb de internet para poder ver una transmisión</li>
                                                <li>● El proyecto tardará aproximadamente 30 semanas en poder hacer el testeo y sacarlo al mercado</li>
                                           </ul>
                                </li>
                            </ol>
                        </div>
                    </div>
                    </article>
                </details>
                <details>
                    <summary>Práctica 4: Lenguaje de Máquina y Arquitectura Computacional</summary>
                    <article class="practica">
                        <div class="titulo_practica">
                            <h2>Práctica 4: Lenguaje de Máquina y Arquitectura Computacional</h2>
                        </div>
                        <div class="descripcion_practica">
                            <p>Este laboratorio trata el proyecto 4, relacionado con lenguaje de
                                máquina puede encontrarse en: <a href="https://www.nand2tetris.org/project04">https://www.nand2tetris.org/project04</a> y
                                busca atacar el proyecto 5: arquitectura computacional, que puede consultarse en: <a href="https://www.nand2tetris.org/project05">
                                https://www.nand2tetris.org/project05</a></p>
                        </div>
                        <div class="desarrollo_practica">
                            <div class="informe">
                                <div class="video_informe">
                                    <iframe width="560" height="315" src="https://www.youtube.com/embed/AGj7rmvMi6w" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                                    <p>El caso de no cargar el video, puede darle click <a href="https://www.youtube.com/watch?v=AGj7rmvMi6w" target="_blank"> Aqui</a></p>
                                </div>
                                <ol>
                                    <li>
                                        <h4>¿Cuál es el objetivo de cada uno de esos proyectos con sus palabras y describa que debe hacer para desarrollarlo?</h4>
                                        <p>El objetivo de esta práctica es el de comprender el lenguaje de máquina mediante en ensamblaje de bajo nivel,
                                            además, se continuará con la construcción de un computador a base de la creación de nuevos chips a base de lo creados
                                            anteriormente en anteriores prácticas.
                                        </p>
                                    </li>
                                    <li>
                                        <h4>Construir las compuertas solicitadas y documentar los resultados:</h4>
                                        <h2>Project 4:</h2>
                                        <ul>
                                            <li>
                                                <h3>MULT.ASM</h3>
                                                <div class="info_compuerta">
                                                    <div class="codigo_compuerta">
                                                        <h4>Código:</h4>
    <pre>
        <code>
    // Multiplies R0 and R1 and stores the result in R2.
    // (R0, R1, R2 refer to RAM[0], RAM[1], and RAM[2], respectively.)

    // Put your code here.
    @R2
    M=0

    @R0
    D=M
    @STEP
    D;JGT

    @END
    0;JMP

    (STEP)
        @R2
        D=M

        @R1
        D=D+M

        @R2
        M=D

        @R0
        D=M-1
        M=D

        @STEP
        D;JGT

    (END)
        @END
        0;JMP
        </code>
    </pre>
                                                    </div>
                                                </div>
                                                <p>Este programa permite realizar la operación de multiplicación entre dos valores de entrada enteros, almacenados en RAM0 y RAM1.
                                                    El resultado de la multiplicación se almacena en RAM2.
                                                    Para la correcta implementación del programa MULT se requirieron adiciones y sustracciones repetitivas en un ciclo.
                                                    El programa tiene estas condiciones: R0>=0, R1>=0, y R0*R1 < 32768, aunque estas no se especifican en el código, son asumidas por este.</p>
                                            </li>
                                            <li>
                                                <h3>FILL.ASM</h3>
                                                <div class="info_compuerta">
                                                    <div class="codigo_compuerta">
                                                        <h4>Código:</h4>
    <pre>
        <code>
    // Runs an infinite loop that listens to the keyboard input.
    // When a key is pressed (any key), the program blackens the screen,
    // i.e. writes "black" in every pixel;
    // the screen should remain fully black as long as the key is pressed. 
    // When no key is pressed, the program clears the screen, i.e. writes
    // "white" in every pixel;
    // the screen should remain fully clear as long as no key is pressed.

    // Put your code here.
    (RESTART)
    @SCREEN
    D=A
    @0
    M=D	

    (KBDCHECK)

    @KBD
    D=M
    @BLACK
    D;JGT	
    @WHITE
    D;JEQ	

    @KBDCHECK
    0;JMP

    (BLACK)
    @1
    M=-1	
    @CHANGE
    0;JMP

    (WHITE)
    @1
    M=0	
    @CHANGE
    0;JMP

    (CHANGE)
    @1	
    D=M	

    @0
    A=M	
    M=D	

    @0
    D=M+1	
    @KBD
    D=A-D	

    @0
    M=M+1	
    A=M

    @CHANGE
    D;JGT	
    @RESTART
    0;JMP
        </code>
    </pre>
                                                    </div>
                                                </div>
                                                <p>El fill trabajara sobre las rams para que sea posible poner la pantalla del computador
                                                    se ponga en blanco y negro.
                                                    Para poder ejecutar el fill debemos asignar adecuadamente los valores de direccion de las ram
                                                    tambien se debe aplicar funcionesdependiente de la keyboard y como estos varían la ram.</p>
                                            </li>
                                        </ul>
                                        <h2>Project 5:</h2>
                                        <ul>
                                            <li>
                                                <h3>Compuerta MEMORY</h3>
                                                    <div class="info_compuerta">
                                                        <img src="https://lh3.googleusercontent.com/2kEIS1AU1uG00eFafuYCzhyaTzMcGm7oDuMslvKmQGP8VDrGZy8QmQJwsiQRg9oOGx34TD7fex217nsUNp0Wtef8YjSyyvteiEMkkByK1Iw2QQfwFg2Bj2He9V96XbvCWikwtZH3fsglleYlpjTSPd-BKHpwxzO3jyp9vrS1H8GD-gtrBFPTQNEX8S0Jt_Mrk0HcLsM1Jp54VWzPXrhWTdithtNXdzZLuL1pdEaubG1sZsDLIq7vlj4yh3K_xc1NDirMMaG-RGIeBxeDmZRHfNpD_n6LuwbqahkacsOpLA1wTsjJqQYmkzTJiNIn39CEPuQS8OkRSJ4eO80mTCk8FfkVjRkj1eNOnpv7snOKUJoYbSHJtwvT5jjUQHsl-LGGIZc-Plnp5c4QDKdXyPGGVab6AG26F5fjVoxV10GzKOHH9TaUh0nZcFzNDMhWukAuBUJ1q0YzaF4x7kAZLIuIZ5bD9IntQPiNPZNRNme9X7ujPHvi0AfJHRg-2AaFcC08IKsGn4g8XXOudxWFLsX7fWZw5pz8NOmxntY5D-XaJCFjsj6KqqnQpYSqQwgkH9NRlUbcQIwI65p4MtDVxDdpSaYp5D3fNyxCOaONMRop779hRlV2VyALIaRbK4NHMTEHp-wdhjA2LUNdptNjPDw3J7bdiaDuOA3m3k9d4KzJPp9WXzCFwFmBv7lMsLsq_BJFGcecsz2VLGaiIAAkzmlnKu8a=w1104-h786-no?authuser=0" alt="memory">
                                                        <div class="codigo_compuerta">
                                                            <h4>Código:</h4>
    <pre>
    <code>
    /**
    * The complete address space of the Hack computer's memory,
    * including RAM and memory-mapped I/O. 
    * The chip facilitates read and write operations, as follows:
    *     Read:  out(t) = Memory[address(t)](t)
    *     Write: if load(t-1) then Memory[address(t-1)](t) = in(t-1)
    * In words: the chip always outputs the value stored at the memory 
    * location specified by address. If load==1, the in value is loaded 
    * into the memory location specified by address. This value becomes 
    * available through the out output from the next time step onward.
    * Address space rules:
    * Only the upper 16K+8K+1 words of the Memory chip are used. 
    * Access to address>0x6000 is invalid. Access to any address in 
    * the range 0x4000-0x5FFF results in accessing the screen memory 
    * map. Access to address 0x6000 results in accessing the keyboard 
    * memory map. The behavior in these addresses is described in the 
    * Screen and Keyboard chip specifications given in the book.
    */

    CHIP Memory {
        IN in[16], load, address[15];
        OUT out[16];

        PARTS:
        DMux4Way(in=load, sel=address[13..14], a=loada, b=loadb,
        c=loadc, d=loadd);
        Or(a=loada, b=loadb, out=loadram);
        RAM16K(in=in, load=loadram, address=address[0..13], out=rout);
        Screen(in=in, load=loadc, address=address[0..12], out=sout);
        Keyboard(out=kout);
        Mux4Way16(a=rout, b=rout, c=sout, d=kout,
        sel=address[13..14], out=out);
    }
        </code>
    </pre>
                                                        </div>
                                                    </div>
                                                    <p>La compuerta MEMORY simula la memoria de una computadora, inicialmente se decide que se va a realizar mediante un DMUX4WAY,
                                                        siendo las opciones la memoria (loada, loadb), la pantalla (loadc) o el teclado (loadd),
                                                        debido a que la memoria ocupa dos valores, se utiliza un OR para simplificar tal elección. 
                                                        Posterior a esto, se utilizan las compuertas correspondientes a las selecciones disponibles, siendo 
                                                        estas RAM16K, KEYBOARD y SCREEN, para finalmente mostrar la opción seleccionada mediante el uso de un
                                                        Mux4Way16. 
                                                    </p>
                                            </li>
                                            <li>
                                                <h3>Compuerta CPU</h3>
                                                    <div class="info_compuerta">
                                                        <img src="https://lh3.googleusercontent.com/8_w2G7H8R3gE3DqkmVv3QHpm8qC7wqO-KvM-QmXYAzMR3TqK8ljNctAoxMyEWSpjaQDQJb47wnX604zjn84B4EvMr6xY-vSGPyzv40fiPCprkpkBbWygxLMkIjFJNBAUqSS1a789Q5DdR-vxy2fTi7AR-ukIpfUSKdrzulImc4v1Rr82l-rqf4Cf8Z07QTJNL6kAUYTm3sJ1ralJt7mMuLJSX1TIxtBPo5D4oLjBCTkhoVhd7d0Rdqc39KB723XyZewSCIscPcB0tTLxUkKDqEylxbU4vIFKB9Crv4r1CqYIIHZYuy1r65iQxpc84mhtANAXFBNmEO4rbU6NTEZRMj--8j5-HEnbcZOpHXmM63WygzdmnU92d7odwm0XR4qjz5jt8pPZvpMtyYUdpwIB4w91keAjiaoICmTAcr8AWS-mhqRbjpQgH5cgJH_6ek_FaquTtu8LbIkMbtkV4Th3ALMwAxsPbYsMge50fzsNwTNFC1pC0exxO6kPl7fcupaNLCVHks9hkqmo5AXNnDMyCwXVZJnTjZnHujZ_ecQj2dFpeP3BDB9H5QkJtV1men_w1vxa3diXugILoFU--gLbda5LXGoV4-kSm--afEcpM1qGOefHv1rtFqWLv_nxrraYowNrQMhJsQeUGtlQAdBuJ4Cj0XN36CyDV74tJgpBqbRzT7fshuzKdp9c40wDd-iExjuLl5EK0tR2A4pHoizsqvK8=w937-h551-no?authuser=0" alt="CPU">
                                                        <div class="codigo_compuerta">
                                                            <h4>Código:</h4>
    <pre>
    <code>
    CHIP CPU {
        IN  inM[16],         // M value input  (M = contents of RAM[A])
            instruction[16], // Instruction for execution
            reset;           // Signals whether to re-start the current
                            // program (reset==1) or continue executing
                            // the current program (reset==0).

        OUT outM[16],        // M value output
            writeM,          // Write to M? 
            addressM[15],    // Address in data memory (of M)
            pc[15];          // address of next instruction

        PARTS:
        Not(in=instruction[15], out=Ains);
        Not(in=Ains, out=Cins);
        
        And(a=Cins, b=instruction[5], out=aALU);    
        Mux16(a=instruction, b=ALUout, sel=aALU, out=Areg);
        
        Or(a=Ains, b=aALU, out=loadA);   
        ARegister(in=Areg, load=loadA, out=Aout);
        
        Mux16(a=Aout, b=inM, sel=instruction[12], out=AMout);  

        And(a=Cins, b=instruction[4], out=loadD);
        DRegister(in=ALUout, load=loadD, out=Dout);   
        
        ALU(x=Dout, y=AMout, zx=instruction[11], nx=instruction[10], 
            zy=instruction[9], ny=instruction[8], f=instruction[7],
            no=instruction[6], out=ALUout, zr=ZRout, ng=NGout); 
            
        Or16(a=false, b=Aout, out[0..14]=addressM);
        Or16(a=false, b=ALUout, out=outM);
        And(a=Cins, b=instruction[3], out=writeM);
        
        And(a=ZRout, b=instruction[1], out=jeq);   
        And(a=NGout, b=instruction[2], out=jlt);    
        Or(a=ZRout, b=NGout, out=zeroOrNeg);
        Not(in=zeroOrNeg, out=positive);           
        And(a=positive, b=instruction[0], out=jgt);
        Or(a=jeq, b=jlt, out=jle);
        Or(a=jle, b=jgt, out=jA);              
        And(a=Cins, b=jA, out=PcL); 
        Not(in=PcL, out=PcI);                  
        PC(in=Aout, inc=PcI, load=PcL, reset=reset, out[0..14]=pc);
    }
        </code>
    </pre>
                                                        </div>
                                                    </div>
                                                    <p>A continuación tenemos el código correspondiente a la compuerta CPU, con sus respectivas 
                                                        entradas que vienen del vector de datos de la RAM, sus salidas y cada una de las partes que 
                                                        lo componen, entre las partes podemos encontrar compuertas como AND, OR, MULTIPLEXORES entre otras</p>
                                            </li>
                                            <li>
                                                <h3>Compuerta COMPUTER</h3>
                                                    <div class="info_compuerta">
                                                        <img src="https://lh3.googleusercontent.com/w00DgDG2l0PigcS-HsXoIbgMzlUFBfNT1sSoibxRyW5NCZv_3WBIuW5Cq8Hok5GiIrQ0ig_Jx6fxE6XtM5gxQLKeCnWSMmLgaifKZ8ht2qO110bsoWk25OVF1wmvf3JqPRAvBCNF1S3XOUeaWEanfyUEU0OKlMl8yH6YRobDOaCHX7IsJaEVYZlL3OvKAOY3AxJ1ggneMw-VZ7o23BV0YT-lNGExm7URMvfnomCtWvHHrBo5lKsPEMO4_1aahhq38DyUJJIx7Fo5ZAcTp9IWzYrADWh5UDyxSjbzCqkeBC9hn3Sv7AshGsFenI6JYOsDm053M4VROwoCrpVq4xQyhgLWkn4VZnlHElYvzAa7-DUFpcMbvjr8B33iHOkeGiOAqXGE9cPhDf5i_Z7nrPOp5WTMUrEZuejdvfOyex9GeUTCd_rAI6o0zLtU1c1EbB5gVDjo-pc4SWV8w-2fD9NO34IBZ4c71uWDeio_ilD8kfSnSolUhzwhZEXZ946o0P2_PYSiQY_M7PLdmwnTumMXmIxE2TI4snC40lB8g81Ts0-Dj2Ibj7-PeLFV8G5ew0Wkdvc0TyiI4dHMPVEng57AByUVL_CALUWoxSXl2HwPAQBqzbDbopkvW9QHQPguqaEXgtd8fwfrhcSqQmgJP_zmDnmGHEHyMu8DhUNM3bvZkPp5UWOh3xiQBvbLt5SDvxp3TPiUATMg5ObVDvm2laIEUvzi=w749-h606-no?authuser=0" alt="COMPUTER">
                                                        <div class="codigo_compuerta">
                                                            <h4>Código:</h4>
    <pre>
    <code>
    // This file is part of www.nand2tetris.org
    // and the book "The Elements of Computing Systems"
    // by Nisan and Schocken, MIT Press.
    // File name: projects/05/Computer.hdl

    /**
    * The HACK computer, including CPU, ROM and RAM.
    * When reset is 0, the program stored in the computer's ROM executes.
    * When reset is 1, the execution of the program restarts. 
    * Thus, to start a program's execution, reset must be pushed "up" (1)
    * and "down" (0). From this point onward the user is at the mercy of 
    * the software. In particular, depending on the program's code, the 
    * screen may show some output and the user may be able to interact 
    * with the computer via the keyboard.
    */

    CHIP Computer {

        IN reset;

        PARTS:
        
        ROM32K(address=pc,out=instruction);
        CPU(inM=inM,instruction=instruction,reset=reset,outM=outM,
        writeM=writeM,addressM=addressM,pc=pc);
        Memory(in=outM,load=writeM,address=addressM,out=inM);
    }
        </code>
    </pre>
                                                        </div>
                                                    </div>
                                                    <p>A partir de la combinación de las compuertas creadas en este proyecto (la cpu, una rom y una memoria) se tiene
                                                        la compuerta de el computador, la cual es capaz de recibir varias instrucciones (principalmente las instrucciones
                                                        contenidas en la compuerta CPU) en lenguaje de máquina.</p>
                                            </li>
                                        </ul>
                                    </li>
                                </ol>
                            </div>
                        </div>
                    </article>
                </details>
            <div class="next">
                <h1>[PROXIMAMENTE]</h1>
            </div>
        </section>
        <section id="Proyecto">
            <div class="title_section">
                <h2>Proyecto</h2>
            </div>
            <div class="next">
                <h1>[PROXIMAMENTE]</h1>
            </div>
        </SEction>
    </main>
    <footer id="main_footer">
        <div>
            <nav>
                <ul>
                    <li><a href="#Inicio">Inicio</a></li>
                    <li><a href="#Integrantes">Integrantes</a></li>
                    <li><a href="#Practicas">Prácticas</a></li>
                    <li><a href="#Proyecto">Proyecto</a></li>
                </ul>
            </nav>
        </div>
        <div>
            <p>
                Creado por <a href="https://github.com/DALO-eng" target="_blank">DALO-eng</a>
            </p>
        </div>
    </footer>
</body>
</html>